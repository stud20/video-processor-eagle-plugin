/**
 * Video Processor Eagle Plugin - Main Module
 * Modernized and refactored for clarity, maintainability, and reliability
 */

// === Core State Management ===
const AppState = {
  selectedFiles: [],
  currentFile: null,
  batchMode: false,
  modulesLoaded: false,
  eagleReady: false,
  processing: false,
  settings: {
    sensitivity: 0.3,
    quality: 'medium',
    inHandle: 0.5,
    outHandle: 0.5,
    outputMode: 'both'
  }
};

// === Module Loader ===
class ModuleLoader {
  static async load() {
    const modules = [
      'modules/video-analyzer.js',
      'modules/frame-extractor.js', 
      'modules/clip-extractor.js',
      'modules/eagle-importer.js'
    ];
    
    try {
      await Promise.all(modules.map(this.loadScript));
      this.verifyModules();
      AppState.modulesLoaded = true;
      console.log('‚úÖ All modules loaded successfully');
    } catch (error) {
      console.error('‚ùå Module loading failed:', error);
      throw error;
    }
  }
  
  static loadScript(src) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = () => reject(new Error(`Failed to load ${src}`));
      document.head.appendChild(script);
    });
  }
  
  static verifyModules() {
    const required = ['VideoAnalyzer', 'FrameExtractor', 'ClipExtractor', 'EagleImporter'];
    const missing = required.filter(name => !window[name]);
    
    if (missing.length > 0) {
      throw new Error(`Missing modules: ${missing.join(', ')}`);
    }
  }
}

// === Utilities ===
function notify(message, type = 'info') {
  console.log(`[${type.toUpperCase()}] ${message}`);
  
  const notification = document.getElementById('notification');
  if (notification) {
    notification.textContent = message;
    notification.className = `notification ${type}`;
    notification.style.display = 'block';
    
    setTimeout(() => {
      notification.style.display = 'none';
    }, 5000);
  }
}

function updateProgress(current, total, message = '') {
  const progress = document.getElementById('progress');
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  
  if (progress && progressBar && progressText) {
    const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
    progressBar.style.width = `${percentage}%`;
    progressText.textContent = message || `${current}/${total} (${percentage}%)`;
    progress.style.display = total > 0 ? 'block' : 'none';
  }
}

function isVideoFile(extension) {
  const videoExts = ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v'];
  return videoExts.includes(extension?.toLowerCase());
}

function updateUI() {
  const elements = {
    selectedFile: document.getElementById('selectedFile'),
    batchInfo: document.getElementById('batchInfo'),
    processBtn: document.getElementById('processBtn'),
    selectBtn: document.getElementById('selectBtn')
  };
  
  const { selectedFiles, currentFile, batchMode, processing } = AppState;
  
  if (elements.selectedFile) {
    elements.selectedFile.textContent = currentFile?.name || 'No file selected';
  }
  
  if (elements.batchInfo) {
    elements.batchInfo.textContent = batchMode 
      ? `Batch mode: ${selectedFiles.length} files`
      : '';
    elements.batchInfo.style.display = batchMode ? 'block' : 'none';
  }
  
  if (elements.processBtn) {
    elements.processBtn.disabled = processing || !currentFile;
    elements.processBtn.textContent = processing ? 'Processing...' : 'Process Video';
  }
  
  if (elements.selectBtn) {
    elements.selectBtn.disabled = processing;
  }
}

// === Core Video Processing ===
async function processVideo(mode = 'both') {
  if (AppState.processing || !AppState.currentFile) {
    notify('Cannot process: no file selected or already processing', 'warning');
    return;
  }
  
  if (!AppState.modulesLoaded) {
    notify('Processing modules not loaded', 'error');
    return;
  }
  
  AppState.processing = true;
  updateUI();
  
  try {
    if (AppState.batchMode) {
      await processBatch(mode);
    } else {
      await processSingle(AppState.currentFile, mode);
    }
    
    notify('Video processing completed successfully!', 'success');
  } catch (error) {
    console.error('Processing failed:', error);
    notify(`Processing failed: ${error.message}`, 'error');
  } finally {
    AppState.processing = false;
    updateProgress(0, 0);
    updateUI();
  }
}

async function processBatch(mode) {
  const { selectedFiles } = AppState;
  const total = selectedFiles.length;
  
  for (let i = 0; i < total; i++) {
    const file = selectedFiles[i];
    updateProgress(i, total, `Processing ${file.name}...`);
    
    try {
      await processSingle(file, mode);
      notify(`Completed ${i + 1}/${total}: ${file.name}`, 'info');
    } catch (error) {
      console.error(`Failed to process ${file.name}:`, error);
      notify(`Failed: ${file.name} - ${error.message}`, 'error');
    }
  }
  
  updateProgress(total, total, 'Batch processing complete');
}

async function processSingle(file, mode) {
  const { settings } = AppState;
  
  // Step 1: Analyze video for cut detection
  updateProgress(1, 4, 'Analyzing video for cuts...');
  const analyzer = new VideoAnalyzer();
  const cuts = await analyzer.detectCuts(file.path, settings.sensitivity);
  
  // Step 2: Extract frames (if needed)
  if (mode === 'frames' || mode === 'both') {
    updateProgress(2, 4, 'Extracting frames...');
    const frameExtractor = new FrameExtractor();
    await frameExtractor.extractFrames(file.path, cuts, settings);
  }
  
  // Step 3: Extract clips (if needed)
  if (mode === 'clips' || mode === 'both') {
    updateProgress(3, 4, 'Extracting clips...');
    const clipExtractor = new ClipExtractor();
    await clipExtractor.extractClips(file.path, cuts, settings);
  }
  
  // Step 4: Import to Eagle (if available)
  updateProgress(4, 4, 'Importing to Eagle...');
  if (AppState.eagleReady && window.EagleImporter) {
    const importer = new EagleImporter();
    await importer.importResults(file.path, cuts, mode);
  }
}

// === File Selection ===
async function selectVideoFile() {
  if (AppState.processing) {
    notify('Cannot select file while processing', 'warning');
    return;
  }
  
  try {
    const files = await window.electronAPI?.selectFiles?.({
      filters: [{ name: 'Video Files', extensions: ['mp4', 'avi', 'mkv', 'mov', 'wmv', 'flv', 'webm', 'm4v'] }],
      properties: ['openFile', 'multiSelections']
    });
    
    if (files?.length > 0) {
      AppState.selectedFiles = files;
      AppState.currentFile = files[0];
      AppState.batchMode = files.length > 1;
      updateUI();
      notify(`Selected ${files.length} file(s)`, 'success');
    }
  } catch (error) {
    console.error('File selection failed:', error);
    notify('File selection failed', 'error');
  }
}

// === Eagle Integration ===
function initializeEagle() {
  if (typeof eagle === 'undefined') {
    console.log('Eagle API not available');
    return;
  }
  
  try {
    AppState.eagleReady = true;
    console.log('‚úÖ Eagle API initialized');
    
    // Register context menu if supported
    if (eagle.contextMenu?.open) {
      setupContextMenu();
    }
    
    // Auto-detect selected files if supported
    if (eagle.item?.getSelected) {
      autoDetectSelection();
    }
    
  } catch (error) {
    console.error('Eagle initialization failed:', error);
  }
}

function setupContextMenu() {
  document.addEventListener('contextmenu', async (e) => {
    if (!AppState.eagleReady) return;
    
    try {
      const selectedItems = await eagle.item.getSelected();
      const videoFiles = selectedItems.filter(item => isVideoFile(item.ext));
      
      if (videoFiles.length > 0) {
        e.preventDefault();
        
        eagle.contextMenu.open([
          {
            id: 'process-video',
            label: 'üé¨ Process with Video Processor',
            click: () => handleEagleSelection(videoFiles)
          },
          {
            id: 'process-clips',
            label: '‚úÇÔ∏è Extract Clips Only',
            click: () => handleEagleSelection(videoFiles, 'clips')
          },
          {
            id: 'process-frames', 
            label: 'üñºÔ∏è Extract Frames Only',
            click: () => handleEagleSelection(videoFiles, 'frames')
          }
        ]);
      }
    } catch (error) {
      console.error('Context menu error:', error);
    }
  });
}

function handleEagleSelection(files, mode = 'both') {
  AppState.selectedFiles = files;
  AppState.currentFile = files[0];
  AppState.batchMode = files.length > 1;
  updateUI();
  
  if (mode !== 'both') {
    processVideo(mode);
  } else {
    notify(`${files.length} video file(s) selected from Eagle`, 'success');
  }
}

async function autoDetectSelection() {
  if (!AppState.eagleReady) return;
  
  try {
    const selectedItems = await eagle.item.getSelected();
    const videoFiles = selectedItems.filter(item => isVideoFile(item.ext));
    
    if (videoFiles.length > 0) {
      handleEagleSelection(videoFiles);
    }
  } catch (error) {
    console.error('Auto-detection failed:', error);
  }
}

// === Event Listeners ===
function setupEventListeners() {
  // Process button
  const processBtn = document.getElementById('processBtn');
  if (processBtn) {
    processBtn.addEventListener('click', () => processVideo());
  }
  
  // Select button
  const selectBtn = document.getElementById('selectBtn');
  if (selectBtn) {
    selectBtn.addEventListener('click', selectVideoFile);
  }
  
  // Settings controls
  const sensitivitySlider = document.getElementById('sensitivity');
  if (sensitivitySlider) {
    sensitivitySlider.addEventListener('input', (e) => {
      AppState.settings.sensitivity = parseFloat(e.target.value);
      const label = document.getElementById('sensitivityValue');
      if (label) label.textContent = e.target.value;
    });
  }
  
  const qualitySelect = document.getElementById('quality');
  if (qualitySelect) {
    qualitySelect.addEventListener('change', (e) => {
      AppState.settings.quality = e.target.value;
    });
  }
}

// === Initialization ===
document.addEventListener('DOMContentLoaded', async () => {
  console.log('üöÄ Video Processor Plugin initializing...');
  
  try {
    // Load processing modules
    await ModuleLoader.load();
    
    // Setup UI event listeners
    setupEventListeners();
    
    // Initialize Eagle integration
    initializeEagle();
    
    // Update initial UI state
    updateUI();
    
    console.log('‚úÖ Video Processor Plugin ready');
    
    // Auto-detect if Eagle is ready
    if (AppState.eagleReady) {
      setTimeout(autoDetectSelection, 500);
    }
    
  } catch (error) {
    console.error('‚ùå Plugin initialization failed:', error);
    notify('Plugin initialization failed', 'error');
  }
});

// === Global API ===
window.VideoProcessor = {
  processVideo,
  selectVideoFile
};
  AppState.selectedFiles = files;
  AppState.currentFile = files[0];
  AppState.batchMode = files.length > 1;
  updateUI();
  
  if (mode !== 'both') {
    processVideo(mode);
  } else {
    notify(`${files.length} video file(s) selected from Eagle`, 'success');
  }
async function autoDetectSelection() {
  if (!AppState.eagleReady) return;
  
  try {
    const selectedItems = await eagle.item.getSelected();
    const videoFiles = selectedItems.filter(item => isVideoFile(item.ext));
    
    if (videoFiles.length > 0) {
      handleEagleSelection(videoFiles);
    }
  } catch (error) {
    console.error('Auto-detection failed:', error);
  }
}

// === Event Listeners ===
function setupEventListeners() {
  // Process button
  const processBtn = document.getElementById('processBtn');
  if (processBtn) {
    processBtn.addEventListener('click', () => processVideo());
  }
  
  // Select button
  const selectBtn = document.getElementById('selectBtn');
  if (selectBtn) {
    selectBtn.addEventListener('click', selectVideoFile);
  }
  
  // Settings controls
  const sensitivitySlider = document.getElementById('sensitivity');
  if (sensitivitySlider) {
    sensitivitySlider.addEventListener('input', (e) => {
      AppState.settings.sensitivity = parseFloat(e.target.value);
      const label = document.getElementById('sensitivityValue');
      if (label) label.textContent = e.target.value;
    });
  }
  
  const qualitySelect = document.getElementById('quality');
  if (qualitySelect) {
    qualitySelect.addEventListener('change', (e) => {
      AppState.settings.quality = e.target.value;
    });
  }
}

// === Initialization ===
document.addEventListener('DOMContentLoaded', async () => {
  console.log('üöÄ Video Processor Plugin initializing...');
  
  try {
    // Load processing modules
    await ModuleLoader.load();
    
    // Setup UI event listeners
    setupEventListeners();
    
    // Initialize Eagle integration
    initializeEagle();
    
    // Update initial UI state
    updateUI();
    
    console.log('‚úÖ Video Processor Plugin ready');
    
    // Auto-detect if Eagle is ready
    if (AppState.eagleReady) {
      setTimeout(autoDetectSelection, 500);
    }
    
  } catch (error) {
    console.error('‚ùå Plugin initialization failed:', error);
    notify('Plugin initialization failed', 'error');
  }
});

// === Global API ===
window.VideoProcessor = {
  processVideo,
  selectVideoFile
};
    elements.duplicateHandling = document.getElementById('duplicateHandling');
    elements.extractionMethod = document.getElementById('extractionMethod');
    
    // Ï∫êÏãú Í¥ÄÎ¶¨ ÏöîÏÜå
    elements.clearCacheBtn = document.getElementById('clearCacheBtn');
    elements.checkCacheBtn = document.getElementById('checkCacheBtn');
    elements.cacheResult = document.getElementById('cacheResult');
    elements.cacheResultContent = document.getElementById('cacheResultContent');


/**
 * ÏßÑÌñâÎ•† ÌëúÏãú
 * @param {number} progress - ÏßÑÌñâÎ•† (0-1)
 * @param {string} message - ÌëúÏãúÌï† Î©îÏãúÏßÄ
 */
function showProgress(progress, message) {
    if (elements.progressSection) {
        elements.progressSection.style.display = 'block';
    }
    
    if (elements.progressFill) {
        elements.progressFill.style.width = `${progress * 100}%`;
    }
    
    if (elements.progressText) {
        elements.progressText.textContent = message;
    }
    
    console.log(`üìä ÏßÑÌñâÎ•† ${(progress * 100).toFixed(1)}%: ${message}`);
}

/**
 * Ï≤òÎ¶¨ Í≤∞Í≥º ÌëúÏãú
 * @param {Object} result - Ï≤òÎ¶¨ Í≤∞Í≥º
 * @param {number} processingTime - Ï≤òÎ¶¨ ÏãúÍ∞Ñ (Ï¥à)
 */
function showResults(result, processingTime) {
    if (!elements.resultsSection) return;
    
    elements.resultsSection.style.display = 'block';
    
    const summary = [];
    if (result.cutPoints > 0) summary.push(`${result.cutPoints}Í∞ú Ïª∑ Î≥ÄÌôî`);
    if (result.extractedFrames > 0) summary.push(`${result.extractedFrames}Í∞ú ÌîÑÎ†àÏûÑ`);
    if (result.extractedClips > 0) summary.push(`${result.extractedClips}Í∞ú ÌÅ¥Î¶Ω`);
    
    if (elements.resultSummary) {
        elements.resultSummary.innerHTML = `
            <div class="result-item">
                <span class="result-label">Ï≤òÎ¶¨ Í≤∞Í≥º:</span>
                <span class="result-value">${summary.join(', ')}</span>
            </div>
            <div class="result-item">
                <span class="result-label">Ï≤òÎ¶¨ ÏãúÍ∞Ñ:</span>
                <span class="result-value">${processingTime.toFixed(1)}Ï¥à</span>
            </div>
            <div class="result-item">
                <span class="result-label">ÌååÏùº:</span>
                <span class="result-value">${currentVideoFile.name}</span>
            </div>
        `;
    }
}

/**
 * Î∞∞Ïπò Ï≤òÎ¶¨ Í≤∞Í≥º ÌëúÏãú
 * @param {Array} batchResults - Î∞∞Ïπò Ï≤òÎ¶¨ Í≤∞Í≥º Î∞∞Ïó¥
 * @param {number} totalTime - Ï¥ù Ï≤òÎ¶¨ ÏãúÍ∞Ñ (Ï¥à)
 * @param {boolean} cancelled - Ï∑®ÏÜå Ïó¨Î∂Ä
 */
function showBatchResults(batchResults, totalTime, cancelled) {
    if (!elements.batchResultsSection) return;
    
    elements.batchResultsSection.style.display = 'block';
    
    const successCount = batchResults.filter(r => r.success).length;
    const failCount = batchResults.length - successCount;
    
    let html = `
        <div class="batch-summary">
            <h3>Î∞∞Ïπò Ï≤òÎ¶¨ ${cancelled ? '(Ï∑®ÏÜåÎê®)' : 'ÏôÑÎ£å'}</h3>
            <div class="batch-stats">
                <span class="success">‚úÖ ÏÑ±Í≥µ: ${successCount}Í∞ú</span>
                <span class="fail">‚ùå Ïã§Ìå®: ${failCount}Í∞ú</span>
                <span class="time">‚è±Ô∏è Ï¥ù ÏãúÍ∞Ñ: ${totalTime.toFixed(1)}Ï¥à</span>
            </div>
        </div>
        <div class="batch-details">
    `;
    
    batchResults.forEach((result, index) => {
        const status = result.success ? '‚úÖ' : '‚ùå';
        const error = result.error ? ` (${result.error})` : '';
        html += `
            <div class="batch-result-item ${result.success ? 'success' : 'error'}">
                <span class="batch-index">${index + 1}.</span>
                <span class="batch-status">${status}</span>
                <span class="batch-filename">${result.fileName}</span>
                <span class="batch-time">${result.processingTime.toFixed(1)}s</span>
                ${error ? `<span class="batch-error">${error}</span>` : ''}
            </div>
        `;
    });
    
    html += '</div>';
    
    if (elements.batchResultsList) {
        elements.batchResultsList.innerHTML = html;
    }
    
    // Ï†ÑÏ≤¥ Í≤∞Í≥º ÏïåÎ¶º
    const message = cancelled 
        ? `Î∞∞Ïπò Ï≤òÎ¶¨ Ï∑®ÏÜåÎê®: ${successCount}/${batchResults.length}Í∞ú ÏôÑÎ£å`
        : `Î∞∞Ïπò Ï≤òÎ¶¨ ÏôÑÎ£å: ${successCount}/${batchResults.length}Í∞ú ÏÑ±Í≥µ`;
    
    showNotification(message, cancelled ? 'warning' : (failCount > 0 ? 'warning' : 'success'));
}

/**
 * Eagle API ÏùòÏ°¥ÏÑ± ÌôïÏù∏
 */
async function checkFFmpegDependency() {
    try {
        if (typeof eagle.extraModule === 'undefined' || typeof eagle.extraModule.ffmpeg === 'undefined') {
            console.warn('Eagle extraModule.ffmpegÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
            return false;
        }
        
        const isInstalled = await eagle.extraModule.ffmpeg.isInstalled();
        
        if (!isInstalled) {
            console.log('FFmpeg ÏùòÏ°¥ÏÑ±Ïù¥ ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. ÏÑ§ÏπòÎ•º ÏãúÎèÑÌï©ÎãàÎã§.');
            showNotification('FFmpeg ÏùòÏ°¥ÏÑ±ÏùÑ ÏÑ§ÏπòÌïòÍ≥† ÏûàÏäµÎãàÎã§...', 'info');
            
            try {
                await eagle.extraModule.ffmpeg.install();
                showNotification('FFmpeg ÏùòÏ°¥ÏÑ± ÏÑ§ÏπòÍ∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.', 'success');
                return true;
            } catch (installError) {
                console.error('FFmpeg ÏùòÏ°¥ÏÑ± ÏÑ§Ïπò Ïã§Ìå®:', installError);
                showNotification('FFmpeg ÏùòÏ°¥ÏÑ± ÏÑ§ÏπòÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.', 'error');
                return false;
            }
        } else {
            console.log('FFmpeg ÏùòÏ°¥ÏÑ±Ïù¥ Ïù¥ÎØ∏ ÏÑ§ÏπòÎêòÏñ¥ ÏûàÏäµÎãàÎã§.');
            return true;
        }
    } catch (error) {
        console.error('FFmpeg ÏùòÏ°¥ÏÑ± ÌôïÏù∏ Ïã§Ìå®:', error);
        return false;
    }
}

/**
 * Eagle FFmpeg Î∞îÏù¥ÎÑàÎ¶¨ Í≤ΩÎ°ú Í∞ÄÏ†∏Ïò§Í∏∞
 */
async function getFFmpegPaths() {
    try {
        if (typeof eagle.extraModule === 'undefined' || typeof eagle.extraModule.ffmpeg === 'undefined') {
            throw new Error('Eagle extraModule.ffmpegÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
        }
        
        const paths = await eagle.extraModule.ffmpeg.getPaths();
        console.log('FFmpeg Î∞îÏù¥ÎÑàÎ¶¨ Í≤ΩÎ°ú:', paths);
        
        return {
            ffmpeg: paths.ffmpeg,
            ffprobe: paths.ffprobe
        };
    } catch (error) {
        console.error('FFmpeg Í≤ΩÎ°ú Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error);
        throw error;
    }
}

/**
 * Ï∫êÏãú ÏÉÅÌÉú ÌôïÏù∏
 */
async function checkCacheStatus() {
    if (!window.eagleUtils) {
        console.error('eagleUtilsÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
        return;
    }
    
    const fs = eagleUtils.getFS();
    if (!fs) return;
    
    let totalFiles = 0;
    let totalSize = 0;
    
    for (const dirPath of eagleUtils.getAllCacheDirectories()) {
        try {
            if (fs.existsSync(dirPath)) {
                const files = fs.readdirSync(dirPath);
                for (const file of files) {
                    const filePath = eagleUtils.joinPath(dirPath, file);
                    const stats = fs.statSync(filePath);
                    if (stats.isFile()) {
                        totalFiles++;
                        totalSize += stats.size;
                    }
                }
            }
        } catch (error) {
            console.error('Ï∫êÏãú ÌôïÏù∏ Ïã§Ìå®:', error);
        }
    }
    
    const resultEl = document.getElementById('cacheResult');
    const contentEl = document.getElementById('cacheResultContent');
    
    if (resultEl && contentEl) {
        resultEl.style.display = 'block';
        if (totalFiles === 0) {
            resultEl.className = 'cache-result success';
            contentEl.innerHTML = '‚úÖ Ï∫êÏãúÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.';
        } else {
            resultEl.className = 'cache-result warning';
            contentEl.innerHTML = `üìä Ï¥ù ${totalFiles}Í∞ú ÌååÏùº, ${eagleUtils.formatFileSize(totalSize)}`;
        }
    }
}

/**
 * Ï∫êÏãú Ï†ïÎ¶¨
 */
async function clearCache() {
    if (!confirm('Î™®Îì† Ï∫êÏãú ÌååÏùºÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) return;
    
    if (!window.eagleUtils) {
        console.error('eagleUtilsÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
        return;
    }
    
    const resultEl = document.getElementById('cacheResult');
    const contentEl = document.getElementById('cacheResultContent');
    
    if (resultEl && contentEl) {
        resultEl.style.display = 'block';
        resultEl.className = 'cache-result info';
        contentEl.innerHTML = 'Ï∫êÏãúÎ•º ÏÇ≠Ï†ú Ï§ë...';
    }
    
    try {
        const result = await eagleUtils.clearAllCache();
        if (resultEl && contentEl) {
            if (result.success) {
                resultEl.className = 'cache-result success';
                contentEl.innerHTML = `‚úÖ ${result.deletedFiles}Í∞ú ÌååÏùº ÏÇ≠Ï†ú ÏôÑÎ£å`;
            } else {
                resultEl.className = 'cache-result error';
                contentEl.innerHTML = '‚ùå ÏùºÎ∂Ä ÌååÏùº ÏÇ≠Ï†ú Ïã§Ìå®';
            }
        }
    } catch (error) {
        if (resultEl && contentEl) {
            resultEl.className = 'cache-result error';
            contentEl.innerHTML = `‚ùå ÏÇ≠Ï†ú Ïã§Ìå®: ${error.message}`;
        }
    }
}

/**
 * Í≤∞Í≥º Ìè¥Îçî Ïó¥Í∏∞
 */
function openResultsFolder() {
    try {
        if (!window.eagleUtils) {
            console.error('eagleUtilsÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
            alert('Í≤∞Í≥º Ìè¥ÎçîÎ•º Ïó¥ Ïàò ÏóÜÏäµÎãàÎã§.');
            return;
        }
        
        // Ï∫êÏãú ÎîîÎ†âÌÜ†Î¶¨Îì§ Í∞ÄÏ†∏Ïò§Í∏∞
        const directories = eagleUtils.getAllCacheDirectories();
        
        if (directories.length === 0) {
            alert('Ïó¥ Ïàò ÏûàÎäî Í≤∞Í≥º Ìè¥ÎçîÍ∞Ä ÏóÜÏäµÎãàÎã§.');
            return;
        }
        
        // Ï≤´ Î≤àÏß∏ ÎîîÎ†âÌÜ†Î¶¨Î•º Ïó¥Í∏∞ (clips Ìè¥Îçî)
        const targetDir = directories[0]; // '/Users/ysk/assets/temp/clips'
        
        // macOSÏóêÏÑú FinderÎ°ú Ìè¥Îçî Ïó¥Í∏∞
        if (typeof eagle !== 'undefined' && eagle.shell && eagle.shell.openPath) {
            eagle.shell.openPath(targetDir);
        } else {
            // Ìè¥Î∞±: ÏãúÏä§ÌÖú Î™ÖÎ†πÏñ¥ ÏÇ¨Ïö©
            const { spawn } = eagleUtils.getNodeModule('child_process') || {};
            if (spawn) {
                spawn('open', [targetDir]);
            } else {
                console.warn('Ìè¥Îçî Ïó¥Í∏∞Î•º ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
                alert(`Í≤∞Í≥º Ìè¥Îçî Í≤ΩÎ°ú: ${targetDir}`);
            }
        }
        
        console.log('Í≤∞Í≥º Ìè¥Îçî Ïó¥Í∏∞:', targetDir);
        
    } catch (error) {
        console.error('Í≤∞Í≥º Ìè¥Îçî Ïó¥Í∏∞ Ïã§Ìå®:', error);
        alert('Í≤∞Í≥º Ìè¥ÎçîÎ•º Ïó¥ Ïàò ÏóÜÏäµÎãàÎã§.');
    }
}

// ÌîåÎü¨Í∑∏Ïù∏ Ï¥àÍ∏∞Ìôî
document.addEventListener('DOMContentLoaded', async () => {
    console.log('Video Processor ÌîåÎü¨Í∑∏Ïù∏ Ï¥àÍ∏∞Ìôî ÏãúÏûë...');
    
    try {
        // DOM ÏöîÏÜå Ï¥àÍ∏∞Ìôî
        initializeElements();
        
        // Eagle API ÌôïÏù∏
        if (typeof eagle !== 'undefined') {
            console.log('Eagle API ÏÇ¨Ïö© Í∞ÄÎä•:', eagle.app?.version || 'unknown');
        } else {
            console.warn('Eagle APIÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§. ÏùºÎ∂Ä Í∏∞Îä•Ïù¥ Ï†úÌïúÎê† Ïàò ÏûàÏäµÎãàÎã§.');
        }
        
        // Ï†ÑÏó≠ Ïú†Ìã∏Î¶¨Ìã∞ ÌôïÏù∏ Î∞è Î™®Îìà ÏÉÅÌÉú ÏÑ§Ï†ï
        if (typeof eagleUtils !== 'undefined') {
            console.log('EagleUtils Î°úÎìú ÏôÑÎ£å');
        } else {
            console.error('EagleUtilsÍ∞Ä Î°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
        }
        
        if (typeof configManager !== 'undefined') {
            console.log('ConfigManager Î°úÎìú ÏôÑÎ£å');
        } else {
            console.error('ConfigManagerÍ∞Ä Î°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
        }
        
        // Ï≤òÎ¶¨ Î™®ÎìàÎì§ ÌôïÏù∏
        const requiredModules = ['VideoAnalyzer', 'FrameExtractor', 'ClipExtractor', 'EagleImporter'];
        const availableModules = requiredModules.filter(module => window[module]);
        
        console.log('ÌôïÏù∏Îêú Î™®ÎìàÎì§:', availableModules);
        console.log('Ï†ÑÏó≠ Í∞ùÏ≤¥ ÏÉÅÌÉú:', {
            VideoAnalyzer: typeof window.VideoAnalyzer,
            FrameExtractor: typeof window.FrameExtractor,
            ClipExtractor: typeof window.ClipExtractor,
            EagleImporter: typeof window.EagleImporter,
            eagleUtils: typeof window.eagleUtils,
            configManager: typeof window.configManager
        });
        
        if (availableModules.length === requiredModules.length) {
            console.log('‚úÖ Î™®Îì† Ï≤òÎ¶¨ Î™®Îìà Î°úÎìú ÏôÑÎ£å:', availableModules);
            modulesLoaded = true;
        } else {
            const missingModules = requiredModules.filter(module => !window[module]);
            console.warn('‚ö†Ô∏è ÏùºÎ∂Ä Î™®ÎìàÏù¥ Î°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§:', missingModules);
            console.log('ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î™®Îìà:', availableModules);
            
            // ÌïÑÏàò Î™®ÎìàÏù¥ ÏóÜÏñ¥ÎèÑ Í∏∞Î≥∏ Í∏∞Îä•ÏùÄ ÎèôÏûëÌïòÎèÑÎ°ù ÏÑ§Ï†ïÌïòÎêò, Îçî ÏûêÏÑ∏Ìïú Î°úÍ∑∏ Ï∂úÎ†•
            if (availableModules.length > 0) {
                console.log('ÏùºÎ∂Ä Î™®ÎìàÎßåÏúºÎ°úÎèÑ ÎèôÏûëÏùÑ ÏãúÎèÑÌï©ÎãàÎã§.');
                modulesLoaded = true;
            } else {
                console.error('Ï≤òÎ¶¨ Î™®ÎìàÏù¥ Ï†ÑÌòÄ Î°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
                modulesLoaded = false;
            }
        }
        
        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
        setupEventListeners();
        
        // Eagle API Ïó∞Îèô ÏÑ§Ï†ï
        checkEagleAPI();
        setupContextMenuIntegration();
        
        // Ï¥àÍ∏∞ UI ÏÉÅÌÉú ÏÑ§Ï†ï
        updateSensitivityValue();
        updateQualityValue();
        updateInHandleValue();
        updateOutHandleValue();
        
        console.log('Video Processor ÌîåÎü¨Í∑∏Ïù∏ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
        
        // EagleÏù¥ Ïù¥ÎØ∏ Ï§ÄÎπÑÎêòÏñ¥ ÏûàÎã§Î©¥ Ï¶âÏãú ÏûêÎèô Í∞êÏßÄ ÏãúÎèÑ
        if (isEagleReady && modulesLoaded) {
            setTimeout(() => {
                autoDetectSelectedFile();
            }, 500);
        }
        
    } catch (error) {
        console.error('ÌîåÎü¨Í∑∏Ïù∏ Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
        alert(`ÌîåÎü¨Í∑∏Ïù∏ Ï¥àÍ∏∞ÌôîÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ${error.message}`);
    }
});

// Ï†ÑÏó≠ Ìï®Ïàò Îì±Î°ù (ÏµúÏÜåÌôî)
window.VideoProcessor = {
  processVideo,
  selectVideoFile
};