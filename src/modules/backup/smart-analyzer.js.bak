/**
 * SmartAnalyzer - ìŠ¤ë§ˆíŠ¸ ì»· ë¶„ì„ ë° ê·¸ë£¹í™” ëª¨ë“ˆ
 * ì—„ê²©í•œ ìœ ì‚¬ë„ ê¸°ë°˜ìœ¼ë¡œ ì»·ì„ ê·¸ë£¹í™”í•©ë‹ˆë‹¤.
 */

// ë¸Œë¼ìš°ì € í™˜ê²½ì—ì„œ í•„ìš”í•œ ì „ì—­ ë³€ìˆ˜ë“¤
const fs_sa = window.require ? window.require('fs') : null;
const path_sa = window.require ? window.require('path') : null;
const { spawn: spawn_sa } = window.require ? window.require('child_process') : { spawn: null };

class SmartAnalyzer {
    constructor(ffmpegPaths = null) {
        // í†µí•©ëœ ìºì‹œ ë””ë ‰í† ë¦¬ ì‚¬ìš©
        const os_sa = window.require ? window.require('os') : null;
        const homeDir = os_sa ? os_sa.homedir() : '/tmp';
        this.outputDir = path_sa ? path_sa.join(homeDir, '.video-processor-cache', 'analysis') : `${homeDir}/.video-processor-cache/analysis`;
        this.ffmpegPaths = ffmpegPaths;
        this.ensureOutputDirectory();
    }

    /**
     * ì¸ë„¤ì¼ ìƒì„± - Eagle API í™œìš©
     */
    async generateThumbnails(groups) {
        console.log('ğŸ–Œï¸ ì¸ë„¤ì¼ ìƒì„± ì‹œì‘');
        
        let generatedCount = 0;
        let failedCount = 0;
        
        for (const group of groups) {
            // ëŒ€í‘œ í”„ë ˆì„ ì¸ë„¤ì¼ ìƒì„±
            if (group.representative && group.representative.framePath) {
                const thumbnail = await this.createThumbnailWithEagle(group.representative.framePath);
                if (thumbnail) {
                    group.representative.thumbnail = thumbnail;
                    generatedCount++;
                } else {
                    failedCount++;
                }
            }
            
            // ëª¨ë“  ë©¤ë²„ í”„ë ˆì„ ì¸ë„¤ì¼ ìƒì„±
            for (const member of group.members) {
                if (member.framePath) {
                    const thumbnail = await this.createThumbnailWithEagle(member.framePath);
                    if (thumbnail) {
                        member.thumbnail = thumbnail;
                        generatedCount++;
                    } else {
                        failedCount++;
                    }
                }
            }
        }
        
        console.log(`ğŸ–Œï¸ ì¸ë„¤ì¼ ìƒì„± ì™„ë£Œ: ì„±ê³µ ${generatedCount}ê°œ, ì‹¤íŒ¨ ${failedCount}ê°œ`);
    }

    /**
     * Eagle APIë¥¼ ì‚¬ìš©í•˜ì—¬ ì¸ë„¤ì¼ ìƒì„±
     */
    async createThumbnailWithEagle(filePath) {
        try {
            // Eagle APIê°€ ì‚¬ìš© ê°€ëŠ¥í•œì§€ í™•ì¸
            if (typeof eagle !== 'undefined' && eagle.app && eagle.app.createThumbnailFromPath) {
                console.log('ğŸ¦… Eagle APIë¡œ ì¸ë„¤ì¼ ìƒì„±:', filePath);
                
                // Eagle APIë¡œ ì¸ë„¤ì¼ ìƒì„±
                const img = await eagle.app.createThumbnailFromPath(filePath, {
                    width: 320,
                    height: 240
                });
                
                // base64ë¡œ ë³€í™˜
                const base64 = img.toDataURL();
                console.log('âœ… Eagle ì¸ë„¤ì¼ ìƒì„± ì„±ê³µ:', filePath);
                
                return base64;
            } else {
                // Eagle APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê²½ìš° ê¸°ì¡´ ë°©ë²• ì‚¬ìš©
                console.log('ğŸ“ íŒŒì¼ ì‹œìŠ¤í…œìœ¼ë¡œ ì¸ë„¤ì¼ ìƒì„±:', filePath);
                return await this.fileToBase64(filePath);
            }
        } catch (error) {
            console.error('Eagle ì¸ë„¤ì¼ ìƒì„± ì‹¤íŒ¨:', error);
            // ì‹¤íŒ¨ ì‹œ ê¸°ì¡´ ë°©ë²•ìœ¼ë¡œ í´ë°±
            return await this.fileToBase64(filePath);
        }
    }

    /**
     * íŒŒì¼ì„ base64ë¡œ ë³€í™˜ (í´ë°±ìš©)
     */
    async fileToBase64(filePath) {
        try {
            if (!fs_sa || !fs_sa.existsSync(filePath)) {
                console.warn('ì¸ë„¤ì¼ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ:', filePath);
                return null;
            }
            
            const imageBuffer = fs_sa.readFileSync(filePath);
            const base64 = imageBuffer.toString('base64');
            const mimeType = 'image/jpeg';
            
            return `data:${mimeType};base64,${base64}`;
        } catch (error) {
            console.error('Base64 ë³€í™˜ ì‹¤íŒ¨:', error);
            return null;
        }
    }

    /**
     * ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„± í™•ì¸
     */
    ensureOutputDirectory() {
        if (fs_sa && !fs_sa.existsSync(this.outputDir)) {
            fs_sa.mkdirSync(this.outputDir, { recursive: true });
        }
    }

    /**
     * FFmpeg ê²½ë¡œ ì„¤ì •
     * @param {Object} ffmpegPaths - ffmpeg, ffprobe ê²½ë¡œ ê°ì²´
     */
    setFFmpegPaths(ffmpegPaths) {
        this.ffmpegPaths = ffmpegPaths;
    }

    /**
     * ìŠ¤ë§ˆíŠ¸ ì»· ë¶„ì„ ë° ê·¸ë£¹í™” ë©”ì¸ í•¨ìˆ˜
     * @param {string} videoPath - ë¹„ë””ì˜¤ íŒŒì¼ ê²½ë¡œ
     * @param {Array} cutPoints - ì»· í¬ì¸íŠ¸ ë°°ì—´
     * @param {Object} settings - ë¶„ì„ ì„¤ì •
     * @param {function} progressCallback - ì§„í–‰ë¥  ì½œë°±
     * @returns {Promise<Object>} ê·¸ë£¹í™”ëœ ê²°ê³¼
     */
    async analyzeAndGroupCuts(videoPath, cutPoints, settings = {}, progressCallback = null) {
        try {
            console.log('ğŸ§  ìŠ¤ë§ˆíŠ¸ ì»· ë¶„ì„ ì‹œì‘:', cutPoints.length, 'ê°œì˜ ì»·');
            
            if (progressCallback) progressCallback(0.1, 'í”„ë ˆì„ ì¶”ì¶œ ì¤€ë¹„ ì¤‘...');
            
            // 1ë‹¨ê³„: ê° ì»·ì˜ ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œ
            const frameData = await this.extractRepresentativeFrames(videoPath, cutPoints, progressCallback);
            
            if (progressCallback) progressCallback(0.6, 'ìœ ì‚¬ë„ ë¶„ì„ ì¤‘...');
            
            // 2ë‹¨ê³„: í”„ë ˆì„ ìœ ì‚¬ë„ ë¶„ì„
            const similarityMatrix = await this.analyzeSimilarity(frameData, settings);
            
            if (progressCallback) progressCallback(0.8, 'ê·¸ë£¹í™” ì§„í–‰ ì¤‘...');
            
            // 3ë‹¨ê³„: ì—„ê²©í•œ ê¸°ì¤€ìœ¼ë¡œ ê·¸ë£¹í™”
            const groups = await this.groupBySimilarity(frameData, similarityMatrix, settings);
            
            // 4ë‹¨ê³„: ì¸ë„¤ì¼ ìƒì„± (Eagle API ì‚¬ìš©)
            if (progressCallback) progressCallback(0.9, 'ì¸ë„¤ì¼ ìƒì„± ì¤‘...');
            await this.generateThumbnails(groups);
            
            if (progressCallback) progressCallback(1.0, 'ìŠ¤ë§ˆíŠ¸ ë¶„ì„ ì™„ë£Œ!');
            
            console.log('ğŸ§  ìŠ¤ë§ˆíŠ¸ ë¶„ì„ ì™„ë£Œ:', {
                totalCuts: cutPoints.length,
                groups: groups.length,
                reduction: `${cutPoints.length} â†’ ${groups.length} ê·¸ë£¹ (${((1 - groups.length/cutPoints.length) * 100).toFixed(1)}% ì¶•ì•½)`
            });
            
            return {
                groups: groups,
                originalCuts: cutPoints.length,
                groupCount: groups.length,
                reductionRate: (1 - groups.length/cutPoints.length) * 100
            };
            
        } catch (error) {
            console.error('ìŠ¤ë§ˆíŠ¸ ë¶„ì„ ì‹¤íŒ¨:', error);
            throw new Error('ìŠ¤ë§ˆíŠ¸ ë¶„ì„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message);
        }
    }

    /**
     * ê° ì»·ì˜ ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œ
     * @param {string} videoPath - ë¹„ë””ì˜¤ íŒŒì¼ ê²½ë¡œ
     * @param {Array} cutPoints - ì»· í¬ì¸íŠ¸ ë°°ì—´
     * @param {function} progressCallback - ì§„í–‰ë¥  ì½œë°±
     * @returns {Promise<Array>} í”„ë ˆì„ ë°ì´í„° ë°°ì—´
     */
    async extractRepresentativeFrames(videoPath, cutPoints, progressCallback) {
        const frameData = [];
        const videoName = path_sa ? path_sa.basename(videoPath, path_sa.extname(videoPath)) : 'video';
        
        console.log('ğŸ“¸ ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œ ì‹œì‘:', cutPoints.length, 'ê°œ');
        
        // ë³‘ë ¬ ì²˜ë¦¬ë¡œ ë¹ ë¥´ê²Œ ì¶”ì¶œ
        const batchSize = 4; // ë™ì‹œ ì²˜ë¦¬ ìˆ˜ (ì•ˆì •ì„±ì„ ìœ„í•´ ì¤„ì„)
        
        for (let i = 0; i < cutPoints.length; i += batchSize) {
            const batch = cutPoints.slice(i, i + batchSize);
            
            const batchPromises = batch.map(async (cutPoint, batchIndex) => {
                const globalIndex = i + batchIndex;
                const middleTime = cutPoint.start + (cutPoint.duration / 2);
                const frameFileName = `${videoName}_frame_${(globalIndex + 1).toString().padStart(3, '0')}.jpg`;
                const framePath = path_sa ? path_sa.join(this.outputDir, frameFileName) : `${this.outputDir}/${frameFileName}`;
                
                try {
                    const success = await this.extractSingleFrame(videoPath, middleTime, framePath);
                    
                    if (success) {
                        // í”„ë ˆì„ íŠ¹ì§• ë¶„ì„
                        const features = await this.analyzeFrameFeatures(framePath);
                        
                        return {
                            cutIndex: globalIndex,
                            cutPoint: cutPoint,
                            framePath: framePath,
                            fileName: frameFileName,
                            features: features,
                            timestamp: middleTime
                        };
                    }
                } catch (error) {
                    console.error(`í”„ë ˆì„ ${globalIndex + 1} ì¶”ì¶œ ì‹¤íŒ¨:`, error.message);
                }
                
                return null;
            });
            
            const batchResults = await Promise.allSettled(batchPromises);
            
            // ì„±ê³µí•œ ê²°ê³¼ë§Œ ì¶”ê°€
            batchResults.forEach((result) => {
                if (result.status === 'fulfilled' && result.value) {
                    frameData.push(result.value);
                }
            });
            
            // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
            if (progressCallback) {
                const progress = 0.1 + ((i + batch.length) / cutPoints.length) * 0.5;
                progressCallback(progress, `í”„ë ˆì„ ì¶”ì¶œ: ${Math.min(i + batch.length, cutPoints.length)}/${cutPoints.length}`);
            }
            
            // ë°°ì¹˜ ê°„ ì§§ì€ ëŒ€ê¸°
            if (i + batchSize < cutPoints.length) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
        
        console.log('ğŸ“¸ ëŒ€í‘œ í”„ë ˆì„ ì¶”ì¶œ ì™„ë£Œ:', frameData.length, 'ê°œ');
        return frameData;
    }

    /**
     * ë‹¨ì¼ í”„ë ˆì„ ì¶”ì¶œ
     * @param {string} videoPath - ë¹„ë””ì˜¤ íŒŒì¼ ê²½ë¡œ
     * @param {number} timeSeconds - ì¶”ì¶œí•  ì‹œê°„ (ì´ˆ)
     * @param {string} outputPath - ì¶œë ¥ íŒŒì¼ ê²½ë¡œ
     * @returns {Promise<boolean>} ì„±ê³µ ì—¬ë¶€
     */
    async extractSingleFrame(videoPath, timeSeconds, outputPath) {
        return new Promise((resolve) => {
            const args = [
                '-i', videoPath,
                '-ss', timeSeconds.toFixed(3),
                '-frames:v', '1',
                '-q:v', '2', // ê³ í’ˆì§ˆ
                '-s', '320x240', // ë¶„ì„ìš© ì‘ì€ í¬ê¸°
                '-y',
                outputPath
            ];

            const ffmpeg = spawn_sa(this.ffmpegPaths.ffmpeg, args);
            
            let stderr = '';
            
            ffmpeg.stderr.on('data', (data) => {
                stderr += data.toString();
            });

            ffmpeg.on('close', (code) => {
                if (code === 0 && fs_sa && fs_sa.existsSync(outputPath)) {
                    resolve(true);
                } else {
                    console.warn(`í”„ë ˆì„ ì¶”ì¶œ ì‹¤íŒ¨: ${path_sa.basename(outputPath)}`);
                    resolve(false);
                }
            });

            ffmpeg.on('error', (error) => {
                console.error('FFmpeg í”„ë ˆì„ ì¶”ì¶œ ì˜¤ë¥˜:', error.message);
                resolve(false);
            });
        });
    }

    /**
     * í”„ë ˆì„ íŠ¹ì§• ë¶„ì„ (ê°„ë‹¨í•œ íˆìŠ¤í† ê·¸ë¨ ê¸°ë°˜)
     * @param {string} framePath - í”„ë ˆì„ íŒŒì¼ ê²½ë¡œ
     * @returns {Promise<Object>} í”„ë ˆì„ íŠ¹ì§•
     */
    async analyzeFrameFeatures(framePath) {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” Canvas APIë‚˜ ì´ë¯¸ì§€ ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©
        // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨í•œ ë²„ì „ìœ¼ë¡œ êµ¬í˜„
        return new Promise((resolve) => {
            if (!fs_sa || !fs_sa.existsSync(framePath)) {
                resolve({ histogram: [], brightness: 0, contrast: 0 });
                return;
            }
            
            // íŒŒì¼ í¬ê¸°ì™€ ìˆ˜ì • ì‹œê°„ì„ ê¸°ë°˜ìœ¼ë¡œ ê°„ë‹¨í•œ íŠ¹ì§• ìƒì„±
            const stats = fs_sa.statSync(framePath);
            const fileSize = stats.size;
            const fileName = path_sa.basename(framePath);
            
            // ê°„ë‹¨í•œ í•´ì‹œ ê¸°ë°˜ íŠ¹ì§• (ì‹¤ì œë¡œëŠ” ì´ë¯¸ì§€ ë¶„ì„ì´ í•„ìš”)
            const features = {
                fileSize: fileSize,
                simpleHash: this.generateSimpleHash(fileName + fileSize),
                timestamp: stats.mtime.getTime(),
                // ì‹¤ì œ êµ¬í˜„ ì‹œ ì¶”ê°€í•  íŠ¹ì§•ë“¤:
                // - ìƒ‰ìƒ íˆìŠ¤í† ê·¸ë¨
                // - ì—£ì§€ ê²€ì¶œ ê²°ê³¼
                // - ë°ê¸°/ëŒ€ë¹„
                // - ì–¼êµ´ ê²€ì¶œ (ê°€ëŠ¥í•œ ê²½ìš°)
            };
            
            resolve(features);
        });
    }

    /**
     * ê°„ë‹¨í•œ í•´ì‹œ ìƒì„± (ì‹¤ì œë¡œëŠ” ì´ë¯¸ì§€ í•´ì‹œ ì‚¬ìš©)
     * @param {string} input - ì…ë ¥ ë¬¸ìì—´
     * @returns {string} í•´ì‹œ ê°’
     */
    generateSimpleHash(input) {
        let hash = 0;
        for (let i = 0; i < input.length; i++) {
            const char = input.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 32ë¹„íŠ¸ ì •ìˆ˜ë¡œ ë³€í™˜
        }
        return hash.toString();
    }

    /**
     * ìœ ì‚¬ë„ ë¶„ì„
     * @param {Array} frameData - í”„ë ˆì„ ë°ì´í„° ë°°ì—´
     * @param {Object} settings - ë¶„ì„ ì„¤ì •
     * @returns {Promise<Array>} ìœ ì‚¬ë„ ë§¤íŠ¸ë¦­ìŠ¤
     */
    async analyzeSimilarity(frameData, settings) {
        console.log('ğŸ” ìœ ì‚¬ë„ ë¶„ì„ ì‹œì‘');
        
        const similarity = settings.similarity || 0.95; // ê¸°ë³¸ê°’: 95% ìœ ì‚¬ë„
        const matrix = [];
        
        for (let i = 0; i < frameData.length; i++) {
            matrix[i] = [];
            for (let j = 0; j < frameData.length; j++) {
                if (i === j) {
                    matrix[i][j] = 1.0; // ìê¸° ìì‹ ê³¼ëŠ” 100% ìœ ì‚¬
                } else {
                    // ê°„ë‹¨í•œ ìœ ì‚¬ë„ ê³„ì‚° (ì‹¤ì œë¡œëŠ” ì´ë¯¸ì§€ ë¹„êµ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©)
                    const similarity = this.calculateFrameSimilarity(frameData[i], frameData[j]);
                    matrix[i][j] = similarity;
                }
            }
        }
        
        console.log('ğŸ” ìœ ì‚¬ë„ ë¶„ì„ ì™„ë£Œ');
        return matrix;
    }

    /**
     * ë‘ í”„ë ˆì„ ê°„ ìœ ì‚¬ë„ ê³„ì‚°
     * @param {Object} frame1 - ì²« ë²ˆì§¸ í”„ë ˆì„ ë°ì´í„°
     * @param {Object} frame2 - ë‘ ë²ˆì§¸ í”„ë ˆì„ ë°ì´í„°
     * @returns {number} ìœ ì‚¬ë„ (0-1)
     */
    calculateFrameSimilarity(frame1, frame2) {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì´ë¯¸ì§€ ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©
        // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨í•œ ë²„ì „ìœ¼ë¡œ ì‹œë®¬ë ˆì´ì…˜
        
        // íŒŒì¼ í¬ê¸° ìœ ì‚¬ë„
        const sizeDiff = Math.abs(frame1.features.fileSize - frame2.features.fileSize);
        const maxSize = Math.max(frame1.features.fileSize, frame2.features.fileSize);
        const sizeSimilarity = 1 - (sizeDiff / maxSize);
        
        // ì‹œê°„ ê°„ê²© (ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë” ìœ ì‚¬í•  ê°€ëŠ¥ì„±)
        const timeDiff = Math.abs(frame1.timestamp - frame2.timestamp);
        const timeSimilarity = timeDiff < 5 ? 0.8 : 0.3; // 5ì´ˆ ì´ë‚´ë©´ ìœ ì‚¬í•  ê°€ëŠ¥ì„±
        
        // ê°„ë‹¨í•œ í•´ì‹œ ë¹„êµ
        const hashSimilarity = frame1.features.simpleHash === frame2.features.simpleHash ? 0.9 : 0.1;
        
        // ê°€ì¤‘ í‰ê· 
        const totalSimilarity = (sizeSimilarity * 0.3 + timeSimilarity * 0.3 + hashSimilarity * 0.4);
        
        return Math.max(0, Math.min(1, totalSimilarity));
    }

    /**
     * ì—„ê²©í•œ ê¸°ì¤€ìœ¼ë¡œ ê·¸ë£¹í™”
     * @param {Array} frameData - í”„ë ˆì„ ë°ì´í„° ë°°ì—´
     * @param {Array} similarityMatrix - ìœ ì‚¬ë„ ë§¤íŠ¸ë¦­ìŠ¤
     * @param {Object} settings - ì„¤ì •
     * @returns {Promise<Array>} ê·¸ë£¹ ë°°ì—´
     */
    async groupBySimilarity(frameData, similarityMatrix, settings) {
        console.log('ğŸ¯ ì—„ê²©í•œ ê·¸ë£¹í™” ì‹œì‘');
        
        const threshold = settings.similarityThreshold || 0.95; // 95% ì´ìƒë§Œ ê·¸ë£¹í™”
        const groups = [];
        const assigned = new Set();
        
        for (let i = 0; i < frameData.length; i++) {
            if (assigned.has(i)) continue;
            
            const group = {
                id: groups.length + 1,
                representative: frameData[i], // ëŒ€í‘œ í”„ë ˆì„
                members: [frameData[i]], // ê·¸ë£¹ ë©¤ë²„ë“¤
                memberIndices: [i],
                avgSimilarity: 1.0,
                isGroup: false // ë‹¨ì¼ ì»·ì¸ì§€ ê·¸ë£¹ì¸ì§€
            };
            
            assigned.add(i);
            
            // ë§¤ìš° ìœ ì‚¬í•œ í”„ë ˆì„ë“¤ì„ ì°¾ì•„ì„œ ê·¸ë£¹ì— ì¶”ê°€
            for (let j = i + 1; j < frameData.length; j++) {
                if (assigned.has(j)) continue;
                
                if (similarityMatrix[i][j] >= threshold) {
                    group.members.push(frameData[j]);
                    group.memberIndices.push(j);
                    assigned.add(j);
                    group.isGroup = true;
                }
            }
            
            // í‰ê·  ìœ ì‚¬ë„ ê³„ì‚°
            if (group.members.length > 1) {
                let totalSimilarity = 0;
                let comparisons = 0;
                
                for (let m1 = 0; m1 < group.memberIndices.length; m1++) {
                    for (let m2 = m1 + 1; m2 < group.memberIndices.length; m2++) {
                        totalSimilarity += similarityMatrix[group.memberIndices[m1]][group.memberIndices[m2]];
                        comparisons++;
                    }
                }
                
                group.avgSimilarity = comparisons > 0 ? totalSimilarity / comparisons : 1.0;
            }
            
            groups.push(group);
        }
        
        // ê·¸ë£¹ í¬ê¸°ìˆœìœ¼ë¡œ ì •ë ¬ (í° ê·¸ë£¹ë¶€í„°)
        groups.sort((a, b) => b.members.length - a.members.length);
        
        console.log('ğŸ¯ ê·¸ë£¹í™” ì™„ë£Œ:', {
            totalGroups: groups.length,
            singleCuts: groups.filter(g => !g.isGroup).length,
            actualGroups: groups.filter(g => g.isGroup).length,
            largestGroup: Math.max(...groups.map(g => g.members.length))
        });
        
        return groups;
    }

    /**
     * ê·¸ë£¹ì—ì„œ ì»· ë¶„ë¦¬
     * @param {Array} groups - í˜„ì¬ ê·¸ë£¹ ë°°ì—´
     * @param {number} groupId - ëŒ€ìƒ ê·¸ë£¹ ID
     * @param {number} cutIndex - ë¶„ë¦¬í•  ì»· ì¸ë±ìŠ¤
     * @returns {Array} ì—…ë°ì´íŠ¸ëœ ê·¸ë£¹ ë°°ì—´
     */
    separateCutFromGroup(groups, groupId, cutIndex) {
        console.log(`âœ‚ï¸ ì»· ë¶„ë¦¬: ê·¸ë£¹ ${groupId}ì—ì„œ ì»· ${cutIndex} ë¶„ë¦¬`);
        
        // ëŒ€ìƒ ê·¸ë£¹ ì°¾ê¸°
        const targetGroup = groups.find(g => g.id === groupId);
        if (!targetGroup || targetGroup.members.length <= 1) {
            console.warn('ë¶„ë¦¬í•  ìˆ˜ ì—†ëŠ” ê·¸ë£¹ì…ë‹ˆë‹¤.');
            return groups;
        }
        
        // ë¶„ë¦¬í•  ì»· ì°¾ê¸°
        const cutToSeparate = targetGroup.members.find(m => m.cutIndex === cutIndex);
        if (!cutToSeparate) {
            console.warn('í•´ë‹¹ ì»·ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            return groups;
        }
        
        // ì›ë˜ ê·¸ë£¹ì—ì„œ ì œê±°
        targetGroup.members = targetGroup.members.filter(m => m.cutIndex !== cutIndex);
        targetGroup.memberIndices = targetGroup.memberIndices.filter(idx => 
            targetGroup.members.some(m => m.cutIndex === idx)
        );
        
        // ìƒˆë¡œìš´ ê·¸ë£¹ ìƒì„±
        const newGroup = {
            id: Math.max(...groups.map(g => g.id)) + 1,
            representative: cutToSeparate,
            members: [cutToSeparate],
            memberIndices: [cutIndex],
            avgSimilarity: 1.0,
            isGroup: false,
            separated: true // ë¶„ë¦¬ëœ ê·¸ë£¹ í‘œì‹œ
        };
        
        // ì›ë˜ ê·¸ë£¹ì´ í•˜ë‚˜ë§Œ ë‚¨ìœ¼ë©´ ê·¸ë£¹ í•´ì œ
        if (targetGroup.members.length === 1) {
            targetGroup.isGroup = false;
        }
        
        groups.push(newGroup);
        
        console.log(`âœ‚ï¸ ë¶„ë¦¬ ì™„ë£Œ: ìƒˆ ê·¸ë£¹ ${newGroup.id} ìƒì„±`);
        
        return groups;
    }

    /**
     * ì„ì‹œ íŒŒì¼ ì •ë¦¬
     */
    cleanup() {
        try {
            if (fs_sa && fs_sa.existsSync(this.outputDir)) {
                const files = fs_sa.readdirSync(this.outputDir);
                files.forEach(file => {
                    const filePath = path_sa ? path_sa.join(this.outputDir, file) : `${this.outputDir}/${file}`;
                    if (fs_sa.statSync(filePath).isFile()) {
                        fs_sa.unlinkSync(filePath);
                    }
                });
                console.log('ğŸ§¹ ë¶„ì„ ì„ì‹œ íŒŒì¼ ì •ë¦¬ ì™„ë£Œ');
            }
        } catch (error) {
            console.error('ë¶„ì„ íŒŒì¼ ì •ë¦¬ ì‹¤íŒ¨:', error);
        }
    }
}

// ë¸Œë¼ìš°ì € í™˜ê²½ì—ì„œ ì „ì—­ ê°ì²´ë¡œ ë“±ë¡
window.SmartAnalyzer = SmartAnalyzer;